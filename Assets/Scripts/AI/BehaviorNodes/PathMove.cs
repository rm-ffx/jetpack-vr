using UnityEngine;
using Pathfinding;
using BehaviorDesigner.Runtime;
using BehaviorDesigner.Runtime.Tasks;

/// <summary>
/// Moves the NPC via Pathfinding
/// </summary>
public class PathMove : Action
{
    //public SharedObject npcInfo; // Contains all Info about this NPC
    //private NPCInfo info;

    //public SharedObject seeker; // Contains the Seeker Object
    //private Seeker pathSeeker;

    //public SharedTransform targetPosition; // Transform to where the path will be calculated
    //private Transform target; // Target Transform, to where the path will be calculated

    //public bool updateWaypointPosition;
    //public int updateIntervall;
    //private int currentUpdateIntervall = 0;

    //// Movement Variables
    //public float characterHeight; // Height of the Character
    //private float errorMargin; // How close does the robot need to get before the next waypoint is triggered.

    //// Path Generation Variables
    //private Path path; // Currently active Path
    //private int currentWaypoint = 0; // Currently active Waypoint

    //public override void OnAwake()
    //{
    //    // Cache Variables
    //    info = npcInfo.GetValue() as NPCInfo;
    //    pathSeeker = seeker.GetValue() as Seeker;
    //}

    //public override void OnStart()
    //{
    //    if (updateWaypointPosition) currentUpdateIntervall = 0;
    //    errorMargin = info.moveSpeed * 0.05f;
    //    target = targetPosition.GetValue() as Transform;

    //    // Generate Path
    //    currentWaypoint = 0;
    //    path = null;
    //    pathSeeker.StartPath(transform.position, target.position, OnPathComplete);
    //}

    //public override TaskStatus OnUpdate()
    //{
    //    // Moves the Character
    //    return MoveCharacter();
    //}

    ///// <summary>
    ///// Moves and Rotates the Character
    ///// </summary>
    //public TaskStatus MoveCharacter()
    //{
    //    if (updateWaypointPosition && currentUpdateIntervall >= updateIntervall)
    //    {
    //        currentUpdateIntervall = 0;
    //        return TaskStatus.Success;
    //    }
    //    else if (updateWaypointPosition)
    //    {
    //        currentUpdateIntervall++;
    //    }

    //    // Move Character towards next waypoint
    //    if (path != null)
    //    {
    //        ///////////////////////
    //        // SET POSITION
    //        // Get new Position
    //        Vector2 currentPos = new Vector2(transform.position.x, transform.position.z);
    //        Vector2 waypointPos = new Vector2(path.vectorPath[currentWaypoint].x, path.vectorPath[currentWaypoint].z);
    //        Vector2 dir = (waypointPos - currentPos).normalized;
    //        Vector2 newPos = currentPos + dir * info.moveSpeed * Time.deltaTime;

    //        // Get position Height
    //        RaycastHit hit;
    //        float height = 0;
    //        if (Physics.Raycast(new Vector3(newPos.x, transform.position.y + characterHeight, newPos.y), -Vector3.up * characterHeight * 2, out hit)) height = hit.point.y;

    //        /////////////////////
    //        // SET ROTATION
    //        Quaternion currentRotation = transform.rotation;
    //        transform.LookAt(new Vector3(newPos.x, transform.position.y, newPos.y));
    //        Quaternion newRotation = transform.rotation;

    //        transform.rotation = Quaternion.Slerp(currentRotation, newRotation, info.rotSpeed * Time.deltaTime);

    //        // Move Character
    //        transform.position = new Vector3(newPos.x, height, newPos.y);

    //        // Check if the Character's distance to the target location is close enough to move on to the next waypoint
    //        if (Vector2.Distance(newPos, waypointPos) < errorMargin) currentWaypoint++;

    //        // Target Reached - Abort Movement
    //        if (currentWaypoint == path.vectorPath.Count)
    //        {
    //            path = null;
    //            currentWaypoint = 0;

    //            return TaskStatus.Success;
    //        }
    //        else return TaskStatus.Running;
    //    }
    //    else return TaskStatus.Running;
    //}

    ///// <summary>
    ///// Callback when a path was generated by the seeker
    ///// </summary>
    //public void OnPathComplete(Path p)
    //{
    //    //We got our path back
    //    if (p.error) Debug.Log("Error!");
    //    else path = p;
    //}

    //public override void OnReset()
    //{
    //    currentWaypoint = 0;
    //    path = null;
    //}
}
