using UnityEngine;
using Pathfinding;
using BehaviorDesigner.Runtime;
using BehaviorDesigner.Runtime.Tasks;

/// <summary>
/// Moves the NPC via Pathfinding
/// </summary>
public class PathMove : Action
{
    public SharedTransform targetPosition; // Transform to where the path will be calculated
    private Transform target; // Target Transform, to where the path will be calculated

    // Movement Variables
    public float moveSpeed; // Movement Speed
    public float rotSpeed; // Rotation Speed
    public float characterHeight; // Height of the Character
    private float errorMargin; // How close does the robot need to get before the next waypoint is triggered.

    // Path Generation Variables
    private Seeker seeker;
    private Path path; // Currently active Path
    private int currentWaypoint = 0; // Currently active Waypoint

    public override void OnStart()
    {
        // Cache Variables
        seeker = GetComponent<Seeker>();
        errorMargin = moveSpeed * 0.05f;
        target = targetPosition.GetValue() as Transform;

        // Generate Path
        currentWaypoint = 0;
        path = null;
        seeker.StartPath(transform.position, target.position, OnPathComplete);
    }

    public override TaskStatus OnUpdate()
    {
        // Moves the Character
        return MoveCharacter();
    }

    /// <summary>
    /// Moves and Rotates the Character
    /// </summary>
    public TaskStatus MoveCharacter()
    {
        // Move Character towards next waypoint
        if (path != null)
        {
            ///////////////////////
            // SET POSITION
            // Get new Position
            Vector2 currentPos = new Vector2(transform.position.x, transform.position.z);
            Vector2 waypointPos = new Vector2(path.vectorPath[currentWaypoint].x, path.vectorPath[currentWaypoint].z);
            Vector2 dir = (waypointPos - currentPos).normalized;
            Vector2 newPos = currentPos + dir * moveSpeed * Time.deltaTime;

            // Get position Height
            RaycastHit hit;
            float height = 0;
            if (Physics.Raycast(new Vector3(newPos.x, transform.position.y + characterHeight, newPos.y), -Vector3.up * characterHeight * 2, out hit)) height = hit.point.y;

            /////////////////////
            // SET ROTATION
            Quaternion currentRotation = transform.rotation;
            transform.LookAt(new Vector3(newPos.x, transform.position.y, newPos.y));
            Quaternion newRotation = transform.rotation;

            transform.rotation = Quaternion.Slerp(currentRotation, newRotation, rotSpeed * Time.deltaTime);

            // Move Character
            transform.position = new Vector3(newPos.x, height, newPos.y);

            // Check if the Character's distance to the target location is close enough to move on to the next waypoint
            if (Vector2.Distance(newPos, waypointPos) < errorMargin) currentWaypoint++;

            // Target Reached - Abort Movement
            if (currentWaypoint == path.vectorPath.Count)
            {
                path = null;
                currentWaypoint = 0;

                return TaskStatus.Success;
            }
            else return TaskStatus.Running;
        }
        else return TaskStatus.Running;
    }

    /// <summary>
    /// Callback when a path was generated by the seeker
    /// </summary>
    public void OnPathComplete(Path p)
    {
        //We got our path back
        if (p.error) Debug.Log("Error!");
        else path = p;
    }

    public override void OnReset()
    {
        currentWaypoint = 0;
        path = null;
    }
}
